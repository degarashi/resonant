attribute PrimAttr {
	highp vec3 atPos : POSITION;
	mediump vec2 atTex : TEXCOORD0;
	mediump vec3 atNormal : NORMAL;
}

// ------------- Primitive -------------
varying PrimVary {
	mediump vec2 varTex;
	mediump vec3 varNormal;
	mediump vec3 varPos;
	mediump vec3 varLsPos;
}
uniform PrimUnif {
	highp mat4 sys_mTrans;
	highp mat4 sys_mWorld;
	sampler2D sys_texDiffuse;
	sampler2D m_texLightDepth;
	vec3 m_vLightPos;
	vec3 m_vLightDir;
	vec3 sys_vEyePos;
	vec2 m_depthRange;
	highp mat4 m_mLight;
}
vertexshader(400) PrimVS() {
	vec4 v = vec4(atPos,1);
	gl_Position = v * sys_mTrans;
	v *= sys_mWorld;
	varTex = atTex;

	varNormal = normalize((vec4(atNormal, 0) * sys_mWorld).xyz);
	varPos = v.xyz;
	vec4 lv = v * m_mLight;
	varLsPos = lv.xyw;
}
code Light {
	float Linear(float v, float vmin, float vmax) {
		return (v - vmin) / (vmax - vmin);
	}
	float ClampLinear(float v, float vmin, float vmax) {
		v = min(max(v, vmin), vmax);
		return Linear(v, vmin, vmax);
	}
	vec2 CalcDepth(vec3 vpos, vec3 lpos, vec2 range) {
		float d = distance(vpos, lpos);
		d = Linear(d, range.x, range.y);
		float dx = dFdx(d);
		float dy = dFdy(d);
		float d2 = d*d + 0.25 * (dx*dx + dy*dy);
		return vec2(d, d2);
	}
	float PCF(float d, sampler2D tex, vec2 uv, float diff, float shadow_v, float light_v) {
		float td[4] = {texture2D(tex, uv+vec2(diff,diff)).x < d ? shadow_v : light_v,
						texture2D(tex, uv+vec2(diff,-diff)).x < d ? shadow_v : light_v,
						texture2D(tex, uv+vec2(-diff,diff)).x < d ? shadow_v : light_v,
						texture2D(tex, uv+vec2(-diff,-diff)).x < d ? shadow_v : light_v};
		float tdsum = td[0] + td[1] + td[2] + td[3];
		return tdsum / 4;
	}
	float VariantShadow(float d, vec2 moments, float amount) {
		float p = (d <= moments.x) ? 1 : 0;
		float variance = moments.y - (moments.x * moments.x);
		variance = max(variance, 0.001);
		float d2 = d - moments.x;
		float p_max = variance / (variance+d2*d2);
		p_max = clamp(Linear(p_max, amount, 1.0), 0, 1);

		return max(p, p_max);
	}
	vec2 CalcLight(vec3 vpos, vec3 vnormal, vec3 eyepos, vec3 litpos, float p) {
		vec3 fromEye = normalize(vpos - eyepos);
		vec3 refv = fromEye + vnormal * (-dot(vnormal, fromEye) * 2);
		vec3 toLit = normalize(litpos - vpos);
		float lit = pow(max(0, dot(toLit, refv)), p);
		float lit_d = dot(toLit, vnormal);
		return vec2(lit_d, lit);
	}
	float ClipLight(vec3 vpos, vec3 litpos, vec3 litdir) {
		vec3 toLit = normalize(litpos - vpos);
		float dt = max(0, dot(-toLit, litdir));
		return smoothstep(0.5, 1, dt);
	}
}
fragmentshader(400, Light) PrimFS() {
	vec2 lit = CalcLight(varPos, varNormal, sys_vEyePos, m_vLightPos, 32);
	gl_FragColor = texture2D(sys_texDiffuse, varTex) * (lit.x + lit.y);
	float d = Linear(distance(varPos, m_vLightPos), m_depthRange.x, m_depthRange.y);
	vec2 uv;
	uv.x = (varLsPos.x/varLsPos.z * 0.5) + 0.5;
	uv.y = (varLsPos.y/varLsPos.z * 0.5) + 0.5;
	/* d -= 3e-2; */
	/* float pcf = PCF(d, m_texLightDepth, uv, 1e-3, 0.5, 1.0); */
	/* gl_FragColor.xyz *= pcf;                                                        */
	float s = ClipLight(varPos, m_vLightPos, m_vLightDir);
	if(s > 0.1)
		s *= VariantShadow(d, texture2D(m_texLightDepth, uv).xy, 0.5);
	s = max(0.2, s);
	gl_FragColor.xyz *= vec3(s);
	gl_FragColor.w = 1;
}

// ------------- PrimDepth -------------
varying PrimDepthVary {
	mediump vec3 varPos;
}
uniform PrimDepthUnif {
	highp mat4 sys_mTrans;
	highp mat4 sys_mWorld;
	mediump vec3 m_vLightPos;
	mediump vec2 m_depthRange;
}
vertexshader(400) PrimDepthVS() {
	vec4 v = vec4(atPos,1);
	gl_Position = v * sys_mTrans;
	varPos = (v * sys_mWorld).xyz;
}
fragmentshader(400, Light) PrimDepthFS() {
	gl_FragColor = vec4(CalcDepth(varPos, m_vLightPos, m_depthRange), 0,0);
}

// ------------- CubeDefault -------------
varying CubeVary {
	mediump vec2 varTex;
	mediump vec3 varNormal;
	mediump vec3 varPos;
}
uniform CubeUnif {
	highp mat4 sys_mTrans;
	highp mat4 sys_mWorld;
	sampler2D sys_texDiffuse;
	samplerCube m_texCubeDepth;
	vec3 m_vLightPos;
	vec3 sys_vEyePos;
	vec2 m_depthRange;
}
vertexshader(400) CubeVS() {
	vec4 v = vec4(atPos,1);
	gl_Position = v * sys_mTrans;
	v *= sys_mWorld;
	varTex = atTex;

	varNormal = normalize((vec4(atNormal, 0) * sys_mWorld).xyz);
	varPos = v.xyz;
}
fragmentshader(400, Light) CubeFS() {
	vec2 lit = CalcLight(varPos, varNormal, sys_vEyePos, m_vLightPos, 32);
	gl_FragColor = texture2D(sys_texDiffuse, varTex) * (lit.x + lit.y);
	float d = ClampLinear(distance(varPos, m_vLightPos), m_depthRange.x, m_depthRange.y);
	/* d -= 3e-3; */
	/* const float diff = 1e-3;  */
	/* const float shadow = 0.5; */
	/* float tdsum = textureCube(m_texCubeDepth, -toLit).x < d ? shadow : 1; */
	/* gl_FragColor.xyz *= tdsum; */
	vec3 tmp = normalize(varPos - m_vLightPos);
	tmp.y *= -1;
	float s = VariantShadow(d, textureCube(m_texCubeDepth, tmp).xy, 0.1);
	s = max(s, 0.2);
	gl_FragColor.xyz *= vec3(s);
	gl_FragColor.w = 1;
}

// ------------- Line -------------
attribute LineAttr {
	vec3 atPos : POSITION;
	vec3 atDir : TEXCOORD0;
	vec4 atColor : COLOR;
}
varying LineVary {
	vec4 varColor;
}
uniform LineUnif {
	highp mat4 sys_mTrans;
	float m_lineLength;
}
vertexshader(400) LineVS() {
	vec4 v = vec4(atPos,1);
	v.xyz += atDir * (m_lineLength*0.05f);
	v *= sys_mTrans;
	gl_Position = v;
	varColor = atColor;
}
fragmentshader(400) LineFS() {
	gl_FragColor = varColor;
}

technique Primitive {
	CullFace = true;
	FrontFace = cw;
	Blend = false;
	DepthTest = true;
	DepthMask = true;
	Attribute = PrimAttr;
	LineWidth = 1;
	pass Default {
		Varying = PrimVary;
		Uniform = PrimUnif;
		VertexShader = PrimVS();
		FragmentShader = PrimFS();
	}
	pass Depth {
		Varying = PrimDepthVary;
		Uniform = PrimDepthUnif;
		VertexShader = PrimDepthVS();
		FragmentShader = PrimDepthFS();
	}
	pass CubeDepth {
		Varying = PrimDepthVary;
		Uniform = PrimDepthUnif;
		VertexShader = PrimDepthVS();
		FragmentShader = PrimDepthFS();
	}
	pass CubeDefault {
		Varying = CubeVary;
		Uniform = CubeUnif;
		VertexShader = CubeVS();
		FragmentShader = CubeFS();
	}
	pass Line {
		Attribute = LineAttr;
		Varying = LineVary;
		Uniform = LineUnif;
		VertexShader = LineVS();
		FragmentShader = LineFS();
	}
}
