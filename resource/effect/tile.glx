uniform TileUnif {
	vec3 u_scale;
	vec3 u_tileoffset;
	highp mat4 sys_mViewProj;
	sampler2D u_texDiffuse;
	float u_repeat;
}
attribute TileAttrB {
	highp vec2 a_pos : POSITION;
	mediump vec2 a_tex : TEXCOORD0;
	mediump vec3 a_normal : NORMAL;
}
attribute TileAttr : TileAttrB {
	float a_height : TEXCOORD1;
}
varying TileVary {
	mediump vec3 v_normal;
	mediump vec2 v_tex;
	float v_weight;
}
vertexshader(400) TileVS() {
	vec3 pos = (vec3(a_pos.x, a_height, a_pos.y) + u_tileoffset) * u_scale;
	gl_Position = vec4(pos, 1) * sys_mViewProj;
	v_normal = a_normal;
	v_tex = a_tex * u_repeat;
}
fragmentshader(400) TileFS() {
	gl_FragColor = texture2D(u_texDiffuse, v_tex);
	vec3 nml = normalize(v_normal);
	gl_FragColor *= vec4(vec3(nml.y), 1);
}

attribute STileAttr {
	highp vec2 a_pos : POSITION;
	mediump vec2 a_tex : TEXCOORD0;
	vec3 a_height : TEXCOORD1;
	vec3 a_normalX : TEXCOORD2;
	vec3 a_normalY : TEXCOORD3;
}
uniform STileUnif : TileUnif {
	vec3 u_viewCenter;
	vec2 u_distRange;
	float u_interpolateLevel;

	vec3 sys_vEyePos;
	highp float u_rayleigh;
	highp float u_mie;
	highp float u_mieGain;
	highp vec3 u_sunColor;
	highp vec3 u_sunDir;
}
code Lerp {
	float Lerp(float from, float to, float t) {
		return (to-from) * t + from;
	}
	vec3 Lerp(vec3 from, vec3 to, float t) {
		return (to-from) * t + from;
	}
	float Sigmoid(float val, float gain) {
		return 1.0 / (1.0 + exp(-gain*val));
	}
}
code Scatter {
	float Square(float t) {
		return t*t;
	}
	float Cube(float t) {
		return t*t*t;
	}
	vec3 Cube(vec3 t) {
		return t*t*t;
	}
	float P4(float t) {
		return t*t*t*t;
	}
	vec3 P4(vec3 t) {
		return vec3(P4(t.x), P4(t.y), P4(t.z));
	}
	float Pow2_3(float t) {
		return sqrt(Cube(t));
	}
	float Rayleigh(in float r, in float cos_theta) {
		float pi = 3.141592;
		return 3 / (16*pi) * r * (1 + Square(cos_theta));
	}
	vec3 Rayleigh(in vec3 r, in float cos_theta) {
		return vec3(Rayleigh(r.r, cos_theta),
					Rayleigh(r.g, cos_theta),
					Rayleigh(r.b, cos_theta));
	}
	float _Mie(in float g, in float m_coeff, in float cos_theta) {
		float pi = 3.141592;
		/* return 1 / (4*pi) * m_coeff * Square(1-g)/Pow2_3(1+Square(g)-2*g*cos_theta); */
		return 3 / (8*pi) * m_coeff * (((1-Square(g)) * (1+Square(cos_theta))) / ((2+Square(g))*Pow2_3(1+Square(g)-2*g*cos_theta)));
	}
	vec3 Mie(in float g, in float m_coeff, in float cos_theta) {
		return vec3(_Mie(g, m_coeff, cos_theta),
					_Mie(g, m_coeff, cos_theta),
					_Mie(g, m_coeff, cos_theta));
	}
}
varying STileVary {
	mediump vec3 v_normal;
	mediump vec2 v_tex;
	highp vec3 v_fex;
	highp vec3 v_lin;
}
vertexshader(400, Lerp, Scatter) STileVS() {
	// --------- Tile ---------
	vec3 wpos = (vec3(a_pos.x, 0, a_pos.y) + u_tileoffset) * u_scale;
	float dist = distance(u_viewCenter.xz, wpos.xz);
	float range = u_distRange.y - u_distRange.x;
	float t = clamp((dist-(u_distRange.x + range/2))/(range/2), 0, 1);
	float r = (a_height.z == u_interpolateLevel) ? 1 : 0;
	wpos = (vec3(a_pos.x, Lerp(a_height.y, a_height.x, t*r), a_pos.y) + u_tileoffset) * u_scale;
	v_normal = normalize(Lerp(a_normalY, a_normalX, t*r));
	v_tex = a_tex * u_repeat;
	gl_Position = vec4(wpos, 1) * sys_mViewProj;

	// --------- Scattering ---------
	/* float cos_theta = dot(normalize(sys_vEyePos - wpos), vec3(0,0,-1));//u_sunDir); */
	/* float eyedist = distance(sys_vEyePos, wpos);                                    */
	/* float tmp0 = 1;                                                                 */
	/* float tmp1A = 0.1;                                                              */
	/* vec3 tmp1 = vec3(680*1e-3, 550*1e-3, 480*1e-3);                                 */
	/* tmp1 = 1/P4(tmp1);                                                              */
	/* vec3 exs = exp(-(vec3(tmp1)+tmp0/50) * (eyedist/2e3));                          */
	/* v_fex = exs;                                                                    */
	/* v_lin = (Rayleigh(u_rayleigh, cos_theta) + Mie(u_mieGain, u_mie, cos_theta)) / (u_rayleigh + u_mie) * u_sunColor * (1 - exs); */
	/* v_lin = (Rayleigh(tmp1, cos_theta)*tmp1A + Mie(u_mieGain, tmp0, cos_theta)) / (tmp1A+tmp0/50) * u_sunColor * (vec3(1)-exs); */

	// --------- Scattering ---------
	// float cos_theta = dot(normalize(sys_vEyePos - wpos), normalize(vec3(0,0,-1))); // Dawn
	// float cos_theta = dot(normalize(sys_vEyePos - wpos), normalize(vec3(0,-1,0)));
	float cos_theta = dot(normalize(sys_vEyePos - wpos), normalize(vec3(0,-0.1,-1))); // Dawn
	// float cos_theta = dot(normalize(sys_vEyePos - wpos), normalize(vec3(0,-1,-1))); // Hazy
	float eyedist = distance(sys_vEyePos, wpos);
	// float mie_c = 0.9; // Dawn
	// float mie_c = 0.1; // Daylight
	float mie_c = 0.1; // Twilight
	// float mie_c = 26.1; // Hazy
	vec3 ray_c = vec3(680*1e-3, 550*1e-3, 440*1e-3);
	ray_c = 1/P4(ray_c);
	// vec3 exs = exp(-(ray_c + mie_c) * (eyedist/5e2)); // Dawn
	// vec3 exs = exp(-(ray_c + mie_c) * (eyedist/5e2)); // Daylight
	vec3 exs = exp(-(ray_c + mie_c) * (eyedist/1e2)); // Twilight
	// vec3 exs = exp(-(ray_c + mie_c) * (eyedist/7e2)); // Hazy
	v_fex = exs;
	// v_lin = (Rayleigh(ray_c, cos_theta) + Mie(0.75, mie_c, cos_theta)) / (ray_c + mie_c) * 3 * (vec3(1)-exs); // Dawn
	// v_lin = (Rayleigh(ray_c, cos_theta) + Mie(0.75, mie_c, cos_theta)) / (ray_c + mie_c) * 10 * (vec3(1)-exs); // Daylight
	v_lin = (Rayleigh(ray_c, cos_theta) + Mie(0.75, mie_c, cos_theta)) / (ray_c + mie_c) * 0.2 * (vec3(1)-exs); // Twilght
	// v_lin = (Rayleigh(ray_c, cos_theta) + Mie(0.50, mie_c, cos_theta)) / (ray_c + mie_c) * 3 * (vec3(1)-exs); // Hazy
}
fragmentshader(400) STileFS() {
	vec3 l0 = texture2D(u_texDiffuse, v_tex).rgb;
	gl_FragColor.xyz = l0 * dot(v_normal, normalize(vec3(0,0.1,1)));
	gl_FragColor.xyz *= v_fex;
	gl_FragColor.xyz += v_lin;
	// gl_FragColor.xyz = l0*v_fex*0.25+v_lin; // Daylight
	// gl_FragColor.xyz = l0*v_fex*0.5+v_lin; // Twilight
	// gl_FragColor.xyz *= dot(v_normal, normalize(vec3(0,0.3,1)));
	/* gl_FragColor.xyz = v_lin; */
	/* gl_FragColor.xyz = l0*v_fex + v_lin; */
	gl_FragColor.w = 1;
}

attribute SViewAttr {
	vec3 a_pos : POSITION;
	vec4 a_color : COLOR;
}
uniform SViewUnif {
	mat4 sys_mTrans;
}
varying SViewVary {
	vec4 v_color;
}
vertexshader(400) SViewVS() {
	gl_Position = vec4(a_pos, 1) * sys_mTrans;
	v_color = a_color;
}
fragmentshader(400) SViewFS() {
	gl_FragColor = vec4(1);
}

attribute SkyAttr {
	vec2 a_pos : POSITION;
	vec2 a_tex : TEXCOORD0;
}
uniform SkyUnif {
	mat4 sys_mViewProj;
	mat4 sys_mViewInv;
	vec2 u_skyScale;	// X=高さ Y=横幅
	vec2 u_scrSize;		// 射影平面でのスクリーンサイズ比
}
varying SkyVary {
	vec2 v_scpos;
}
vertexshader(400, Scatter) SkyVS() {
	/* // 描画用の座標                                                                                 */
	/* vec3 wpos = (vec4(a_pos,1) * sys_mWorld).xyz;                                                         */
	/* vec3 wdir = normalize(wpos);                                                                          */
	/* wpos += sys_vEyePos;                                                                                  */
	/* gl_Position = vec4(wpos, 1) * sys_mViewProj;                                                          */
	/* // 実際のスカイドーム座標                                                                  */
	/* vec2 sca = vec2(10, 6000);                                                                            */
	/* wpos = wdir * sca.yxy;                                                                                */
	/* // --------- Scattering ---------                                                                     */
	/* float cos_theta = dot(-wdir, vec3(0,0,-1));                                                           */
	/* float eyedist = length(wpos);                                                                         */
	/* float tmp0 = 0.5;                                                                                     */
	/* vec3 tmp1 = vec3(680*1e-3, 550*1e-3, 440*1e-3)*1.6;                                                   */
	/* tmp1 = 1/P4(tmp1);                                                                                    */
	/* vec3 exs = exp(-(tmp1+tmp0) * (eyedist/1e3));                                                         */
	/* v_fex = exs;                                                                                          */
	/* v_lin = (Rayleigh(tmp1, cos_theta) + Mie(0.75, tmp0, cos_theta)) / (tmp1 + tmp0) * 1 * (vec3(1)-exs); */

	v_scpos = a_pos;
	gl_Position = vec4(a_pos, 0, 1);
}
code Proc {
	vec3 Proc(in vec3 p) {
		// float t = 8/abs(p.y); // Dawn
		float t = 1/p.y; // Daylight
		// float t = 1/abs(p.y); // Hazy
		return vec3(p.x*t, p.y*1, p.z*t);
	}
}
fragmentshader(400, Scatter, Proc) SkyFS() {
	// スクリーン位置からワールド空間での向きを計算
	vec3 vdir = normalize(vec3(v_scpos * u_scrSize, 1));
	vec3 wdir = normalize((vec4(vdir, 0) * sys_mViewInv).xyz);
	// スカイドームとの交点を算出
	vec3 cp = Proc(wdir);//u_skyScale.yxy;
	float eyedist = length(cp);
	// --------- Scattering ---------
	// float cos_theta = dot(-wdir, normalize(vec3(0,0,-1))); // Dawn
	float cos_theta = dot(-wdir, normalize(vec3(0,0,-1))); // Daylight
	// float cos_theta = dot(-normalize(cp), normalize(vec3(0,-1,-1))); // Hazy
	// float cos_theta = dot(-wdir, normalize(vec3(0,0,-1))); // Twilight
	float mie_c = 20.6;
	// float mie_c = 80.0; // Hazy
	vec3 ray_c = vec3(680*1e-3, 550*1e-3, 450*1e-3);
	ray_c = 1/P4(ray_c);
	// vec3 exs = exp(-(ray_c + mie_c) * (eyedist/2e3)); // Dawn
	vec3 exs = exp(-(ray_c + mie_c) * (eyedist/2e2)); // Daylight
	// vec3 exs = exp(-(ray_c + mie_c) * (eyedist)); // Twilight
	// vec3 exs = exp(-(ray_c + mie_c) * (eyedist/1e1)); // Hazy
	// vec3 lin = (Rayleigh(ray_c, cos_theta) + Mie(0.75, mie_c, cos_theta)) / (ray_c + mie_c) * 4.8 * (vec3(1)-exs); // Dawn
	vec3 lin = (Rayleigh(ray_c, cos_theta) + Mie(0.3, mie_c, cos_theta)) / (ray_c + mie_c) * 20.4 * (vec3(1)-exs); // Daylight
	// vec3 lin = (Rayleigh(ray_c, cos_theta) + Mie(0.8, mie_c, cos_theta)) / (ray_c + mie_c) * 5.0 * (vec3(1)-exs); // Hazy
	// vec3 lin = (Rayleigh(ray_c, cos_theta) + Mie(0.75, mie_c, cos_theta))/(ray_c + mie_c) * 1 * (vec3(1)-exs); // Twilight
	gl_FragColor.xyz = lin;
	gl_FragColor.w = 1;
}

technique Tile {
	PolygonMode = Fill;
	CullFace = true;
	FrontFace = cw;
	Blend = false;
	DepthTest = true;
	DepthMask = true;
	DepthFunc = LessEqual;

	pass Default {
		Varying = TileVary;
		Attribute = TileAttr;
		Uniform = TileUnif;
		VertexShader = TileVS();
		FragmentShader = TileFS();
	}
	pass Shader {
		Attribute = STileAttr;
		Uniform = STileUnif;
		Varying = STileVary;
		VertexShader = STileVS();
		FragmentShader = STileFS();
	}
	pass ShaderView {
		PolygonMode = Line;
		DepthMask = false;
		CullFace = true;
		Blend = true;
		BlendFunc = SrcAlpha InvSrcAlpha;

		Attribute = SViewAttr;
		Uniform = SViewUnif;
		Varying = SViewVary;
		VertexShader = SViewVS();
		FragmentShader = SViewFS();
	}
	pass Skydome {
		CullFace = false;
		PolygonMode = Fill;
		DepthTest = false;
		DepthMask = false;
		Attribute = SkyAttr;
		Varying = SkyVary;
		Uniform = SkyUnif;
		VertexShader = SkyVS();
		FragmentShader = SkyFS();
	}
}
